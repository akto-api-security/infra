AWSTemplateFormatVersion: 2010-09-09
Description: AWS cloudFormation template to configure traffic mirroring sessions
Parameters:
  SourceLBs:
    Description: 'Comma separated list of loadblancer names ( eg: lb1, lb2, lb3 )'
    Type: CommaDelimitedList
    Default: ''
  TargetLB:
    Description: Akto NLB ARN
    Type: String
    Default: ''
  AktoAccountId:
    Description: Akto account id where to send the mirrored data
    Type: String
    Default: ''
Resources:
  LBTrafficMirrorFilter:
    Type: 'AWS::EC2::TrafficMirrorFilter'
    Properties:
      Description: Traffic mirror filter for LBs and Target Groups
      NetworkServices:
        - amazon-dns
      Tags:
        - Key: Name
          Value: !Join
            - ''
            - - !Ref 'AWS::StackName'
              - '-'
              - Filter
        - Key: Deployment
          Value: Akto-CloudFormation      
  LambdaLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Sub '/aws/lambda/${CreateMirrorSession}'
      RetentionInDays: 7
  LambdaBasicExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: LBCreateTrafficMirrorSession
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'ec2:DescribeNetworkInterfaces'
                  - 'ec2:DescribeTrafficMirrorSessions'
                  - 'ec2:DescribeInstances'
                  - 'ec2:DescribeVpcs'
                  - 'elasticloadbalancing:DescribeLoadBalancers'
                  - 'elasticloadbalancing:DescribeTargetGroups'
                  - 'elasticloadbalancing:DescribeTargetHealth'
                  - 'ec2:DescribeTrafficMirrorFilters'
                  - 'ec2:DeleteTrafficMirrorFilterRule'
                  - 'ec2:CreateTrafficMirrorFilterRule'
                  - 'ec2:DescribeTrafficMirrorTargets'
                  - 'lambda:InvokeFunction'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'ec2:CreateTrafficMirrorSession'
                Resource:
                  - 'arn:aws:ec2:*:*:traffic-mirror-session/*'
                  - 'arn:aws:ec2:*:*:network-interface/*'
                  - 'arn:aws:ec2:*:*:traffic-mirror-target/*'
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:*:*:traffic-mirror-filter/*'
              - Effect: Allow
                Action:
                  - 'ec2:DeleteTrafficMirrorSession'
                Resource:
                  - 'arn:aws:ec2:*:*:traffic-mirror-session/*'
  GetAktoSetupDetailsLambdaBasicExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: GetAktoSetupDetailsExecuteLambda
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'ec2:DescribeNetworkInterfaces'
                  - 'ec2:DescribeTrafficMirrorSessions'
                  - 'ec2:DescribeInstances'
                  - 'ec2:DescribeVpcs'
                  - 'elasticloadbalancing:DescribeLoadBalancers'
                  - 'elasticloadbalancing:DescribeTargetGroups'
                  - 'elasticloadbalancing:DescribeTargetHealth'
                Resource: '*'                
  LambdaLogPermissions:
    Type: 'AWS::IAM::Policy'
    Properties:
      Roles:
        - !Ref LambdaBasicExecutionRole
      PolicyName: !Sub '${AWS::Region}-LambdaLogGroup'
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
            Resource:
              - !Sub >-
                arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${CreateMirrorSession}
              - !Sub >-
                arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${CreateMirrorSession}:*
              - !Sub >-
                arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${CreateMirrorSession}:*:*
  CustomSourceENIs:
    Type: 'AWS::CloudFormation::CustomResource'
    Properties:
      ServiceToken: !GetAtt
        - CreateMirrorSession
        - Arn
      SourceLBs: !Ref SourceLBs
    DependsOn: LambdaLogGroup
  
  GetAktoSetupDetails:
    Type: 'AWS::Lambda::Function'
    Properties:
      Runtime: nodejs12.x
      Timeout: 60
      Role: !GetAtt
        - GetAktoSetupDetailsLambdaBasicExecutionRole
        - Arn
      Handler: index.handler
      Environment:
        Variables:
          TARGET_LB: !Ref TargetLB
      Code:
        ZipFile: >
          var aws = require('aws-sdk')

          var response = require('cfn-response')

          var targetLB = process.env.TARGET_LB;
          
          async function getAktoLBDetails() {
            var elb = new aws.ELBv2();
              var params = {
                  "LoadBalancerArns" : [targetLB]
              };


              console.log("GASD Getting Akto LB Details : ", JSON.stringify(params));

              var LBDesc = await elb.describeLoadBalancers(params).promise().catch(err=>{
                console.log("Error describing Akto LB",err);
              });
              
              if(!LBDesc.LoadBalancers[0])
              {
                console.log("GASD Could not find Akto Load Balancer");
                return ;
              }
              
              LBDesc = LBDesc.LoadBalancers[0];

              var LBName = targetLB.substring(targetLB.indexOf('/')+1);
              // LBname to get private ip of ENI of LB 

            var eniDesc = 'ELB '+LBName;
              var ec2 = new aws.EC2();
              params = {
                Filters: [{
                  'Name' : 'description',
                  'Values' : [eniDesc]
                }]
              };
              
              var ENIDesc = await ec2.describeNetworkInterfaces(params).promise().catch(err=>{
                    console.log("GASD Error getting ENI Details of ENI with Description ",eniDesc, " error : ",err); 
              });
              
              if(!ENIDesc.NetworkInterfaces[0])
              {
                console.log("GASD Coud not find Network Interface Details");
                return ;
                
              }
              
              console.log("GASD ENIDesc: ",ENIDesc);
              
              LBDesc.PrivateIpAddress  = ENIDesc.NetworkInterfaces[0].PrivateIpAddress;
              LBDesc.Subnets = LBDesc.AvailabilityZones.map(x=>x.SubnetId);
              
              
              
              console.log("GASD LoadBalancerDescription : ",JSON.stringify(LBDesc));
              return LBDesc;
              
          } 

          exports.handler = async function(event, context) {
            if (event.RequestType == "Delete") {
                await response.send(event, context, "SUCCESS");
                return;
            }            
            var responseData = {}
            responseData['successEnis'] = JSON.stringify([]);            

            var aktoDetails = await getAktoLBDetails();
            responseData['kafkaIp'] = aktoDetails.PrivateIpAddress;
            responseData['SubnetId'] = aktoDetails.Subnets;
            responseData['VpcId'] = aktoDetails.VpcId;
            console.log("GASD responseData", responseData);
            await response.send(event, context, "SUCCESS", responseData);
          };

  CustomSourceAktoSetupDetails:
    Type: 'AWS::CloudFormation::CustomResource'
    Properties:
      ServiceToken: !GetAtt
        - GetAktoSetupDetails
        - Arn
      TargetLB: !Ref TargetLB
  
          

  CreateMirrorSession:
    Type: 'AWS::Lambda::Function'
    Properties:
      Runtime: nodejs12.x
      Timeout: 60
      Role: !GetAtt
        - LambdaBasicExecutionRole
        - Arn
      Handler: index.handler
      Environment:
        Variables:
          ELB_NAMES: !Join
            - ','
            - !Ref SourceLBs
          TRAFFIC_MIRROR_FILTER_ID: !Ref LBTrafficMirrorFilter
          TARGET_LB: !Ref TargetLB
          AKTO_ACCOUNT_ID: !Ref AktoAccountId
          SAVE_COLLECTION_NAMES_LAMBDA_ARN: !GetAtt
            - SaveCollectionNames
            - Arn
      Code:
        ZipFile: >
          var aws = require('aws-sdk')

          var response = require('cfn-response')

          var saveCollectionNamesLambdaArn = process.env.SAVE_COLLECTION_NAMES_LAMBDA_ARN;

          var trafficMirrorFilterID = process.env.TRAFFIC_MIRROR_FILTER_ID;

          var mirrorSessionNumber = "1";

          var aktoAccountId = process.env.AKTO_ACCOUNT_ID;

          var tgNamesArray = process.env.ELB_NAMES.split(",").map(item => item.trim());;

          var elbNamesArray = process.env.ELB_NAMES.split(",").map(item => item.trim());;

          var sampleSize = 200;
          var targetLB = process.env.TARGET_LB;
          function filterDuplicates(value, index, self) {
              return self.indexOf(value) === index;
          }

          async function getAktoTrafficMirrorTargetId() {
            var params = {
              Filters: [
                {
                  Name: "network-load-balancer-arn",
                  Values: [targetLB]
                }
              ]
            }

            var ec2 = new aws.EC2();

            var targets = await ec2.describeTrafficMirrorTargets(params).promise().catch(err => {
              console.log(err);
            });

            return targets['TrafficMirrorTargets'][0]['TrafficMirrorTargetId']

          }

          var trafficMirrorTargetID = "";


          function existIn2dArray(src, key) {
              var matched = false;
              for (var i = 0; i < src.length; i++) {
                  matched = true
                  if (src[i].length != key.length)
                      return false
                  for (var j = 0; j < key.length; j++) {
                      if (src[i][j] != key[j]) {
                          matched = false;
                      }
                  }
                  if (matched) {
                      return matched;
                  }
              }
              return matched
          }

          function calcVxLanId(name) {
            var hash = 0;
            if (name.length == 0) return hash;
            for (var i = 0; i < name.length; i++) {
              var char = name.charCodeAt(i);
              hash = ((hash<<5)-hash)+char;
              hash = hash & hash; // Convert to 32bit integer
            }
            return hash & ((2<<20)-1);
          }

          async function getAktoLBDetails() {
            var elb = new aws.ELBv2();
              var params = {
                  "LoadBalancerArns" : [targetLB]
              };


              console.log("Getting Akto LB Details : ", JSON.stringify(params));

              var LBDesc = await elb.describeLoadBalancers(params).promise().catch(err=>{
                console.log("Error describing Akto LB",err);
              });
              
              if(!LBDesc.LoadBalancers[0])
              {
                console.log("Could not find Akto Load Balancer");
                return ;
              }
              
              LBDesc = LBDesc.LoadBalancers[0];

              var LBName = targetLB.substring(targetLB.indexOf('/')+1);
              // LBname to get private ip of ENI of LB 

            var eniDesc = 'ELB '+LBName;
              var ec2 = new aws.EC2();
              params = {
                Filters: [{
                  'Name' : 'description',
                  'Values' : [eniDesc]
                }]
              };
              
              var ENIDesc = await ec2.describeNetworkInterfaces(params).promise().catch(err=>{
                    console.log("Error getting ENI Details of ENI with Description ",eniDesc, " error : ",err); 
              });
              
              if(!ENIDesc.NetworkInterfaces[0])
              {
                console.log("Coud not find Network Interface Details");
                return ;
                
              }
              
              console.log("ENIDesc: ",ENIDesc);
              
              LBDesc.PrivateIpAddress  = ENIDesc.NetworkInterfaces[0].PrivateIpAddress;
              LBDesc.Subnets = LBDesc.AvailabilityZones.map(x=>x.SubnetId);
              
              
              
              console.log("LoadBalancerDescription : ",JSON.stringify(LBDesc));
              return LBDesc;
              
          } 
          
          async function getEnisAndPortOfTargetGroup(params, allPorts, eniList)
          {
              var isError = false;
              var elbv2 = new aws.ELBv2();
              var ec2 = new aws.EC2();
              var i = 0,
                  j = 0,
                  k = 0;
              var targetGroups = await elbv2.describeTargetGroups(params).promise().catch((err) => {
                  console.error(err);
                  isError = true;
              });
              console.log("elbv2 describeTargetGroups ", JSON.stringify(targetGroups));
              if (!isError && targetGroups.TargetGroups != undefined) {
                  for (j = 0; j < targetGroups.TargetGroups.length; j++) {
                      var counter = sampleSize < 1 ? targetGroups.TargetGroups.length : sampleSize;
                      var targetGroupName = targetGroups.TargetGroups[j].TargetGroupName || ("TargetGroups-"+j);
                      isError = false;
                      params = {
                          TargetGroupArn: targetGroups.TargetGroups[j].TargetGroupArn
                      }
                      var backends = await elbv2.describeTargetHealth(params).promise().catch((err) => {
                          console.error(err);
                          isError = true;
                      });
                      console.log("elbv2 describeTargetHealth ", JSON.stringify(backends));
                      if (!isError && backends.TargetHealthDescriptions != undefined) {
                          if (targetGroups.TargetGroups[j].TargetType == "instance") {
                              params = {
                                  Filters: [{
                                      Name: "attachment.instance-id",
                                      Values: [

                                      ]
                                  }]
                              };
                              for (k = 0; k < backends.TargetHealthDescriptions.length && counter > 0; k++) {
                                  params.Filters[0].Values.push(backends.TargetHealthDescriptions[k].Target.Id)
                                  allPorts.push(backends.TargetHealthDescriptions[k].Target.Port)
                                  counter -- 
                              }
                              if (params.Filters[0].Values.length > 0) {
                                  var enis = await ec2.describeNetworkInterfaces(params).promise().catch((err) => {
                                      console.error(err);
                                      isError = true;
                                  });
                                  console.log("elbv2 instance params ", JSON.stringify(params));
                                  console.log("elbv2 instance describeNetworkInterfaces ", JSON.stringify(enis));
                                  if (!isError && enis.NetworkInterfaces != undefined) {
                                      for (var l = 0; l < enis.NetworkInterfaces.length; l++) {
                                          // Use only primary interface
                                          if (enis.NetworkInterfaces[l].Attachment != undefined && enis.NetworkInterfaces[l].Attachment.DeviceIndex == 0) {
                                              eniList.push([targetGroupName, enis.NetworkInterfaces[l].NetworkInterfaceId])
                                          }
                                      }
                                  }
                              }
                          }
                          if (targetGroups.TargetGroups[j].TargetType == "ip") {
                              params = {
                                  Filters: [{
                                      Name: "addresses.private-ip-address",
                                      Values: [

                                      ]
                                  }]
                              };
                              for (k = 0; k < backends.TargetHealthDescriptions.length && counter > 0; k++) {
                                  params.Filters[0].Values.push(backends.TargetHealthDescriptions[k].Target.Id)
                                  allPorts.push(backends.TargetHealthDescriptions[k].Target.Port)
                                  counter -- 
                              }
                              if (params.Filters[0].Values.length > 0) {
                                  var enis = await ec2.describeNetworkInterfaces(params).promise().catch((err) => {
                                      console.error(err);
                                      isError = true;
                                  });
                                  console.log("elbv2 ip params ", JSON.stringify(params));
                                  console.log("elbv2 ip describeNetworkInterfaces ", JSON.stringify(enis));
                                  if (!isError && enis.NetworkInterfaces != undefined) {
                                      for (var l = 0; l < enis.NetworkInterfaces.length; l++) {
                                          eniList.push([targetGroupName, enis.NetworkInterfaces[l].NetworkInterfaceId])
                                      }
                                  }
                              }
                          }
                      }
                  }
              }

          }


          async function updateTrafficMirroringRule(allPorts) {
              //console.log("eniList ", JSON.stringify(eniList))
              var params = {};
              console.log("params ", JSON.stringify(params))
              var isError = false;
              var ec2 = new aws.EC2();
              var i = 0,
                  j = 0;
              params = {
                  Filters: [{
                      Name: "traffic-mirror-filter-id",
                      Values: [
                          trafficMirrorFilterID
                      ]
                  }]
              }
              isError = false;
              var filterList = await ec2.describeTrafficMirrorFilters(params).promise().catch((err) => {
                  console.error(err);
                  isError = true;
              });
              var uniqueAllPorts = allPorts.filter(filterDuplicates);
              uniqueAllPorts.sort(function(a, b) {
                  return a - b;
              });;
              var uniqueAllPortsRange = []
              for (i = 0; i < uniqueAllPorts.length; i++) {
                  uniqueAllPortsRange.push([uniqueAllPorts[i], uniqueAllPorts[i]])
              }
              if (uniqueAllPorts.length > 10) {
                  // only 10 rules are allowed per filter
                  console.log("ports are more than 10, grouping them")
                  var diff = [];
                  for (i = 1; i < uniqueAllPorts.length; i++) {
                      diff.push(uniqueAllPorts[i] - uniqueAllPorts[1]);
                  }
                  console.log("1. uniqueAllPortsRange ", JSON.stringify(uniqueAllPortsRange))
                  console.log("1. diff ", JSON.stringify(diff))
                  for (i = (uniqueAllPortsRange.length - 10); i > 0; i--) {
                      var minDiff = 65535; // max port number
                      var minDiffIndex = 0;
                      for (j = 0; j < diff.length; j++) {
                          if (minDiff > diff[j]) {
                              minDiff = diff[j]
                              minDiffIndex = j;
                          }
                      }

                      uniqueAllPortsRange[minDiffIndex][1] = uniqueAllPortsRange[minDiffIndex + 1][1]
                      uniqueAllPortsRange.splice(minDiffIndex + 1, 1)
                      diff.splice(minDiffIndex, 1)
                      console.log("2. uniqueAllPortsRange ", JSON.stringify(uniqueAllPortsRange))
                      console.log("2. diff ", JSON.stringify(diff))
                  }
              }
              console.log("describe mirror filters ", JSON.stringify(filterList))
              console.log("uniqueAllPortsRange ", JSON.stringify(uniqueAllPortsRange))
              var existingUnsedPorts = []
              var unusedFilterId = []
              var maxRuleNumber = 1
              if (!isError && filterList.TrafficMirrorFilters != undefined) {
                  for (i = 0; i < filterList.TrafficMirrorFilters.length; i++) {

                      for (j = 0; j < filterList.TrafficMirrorFilters[i].IngressFilterRules.length; j++) {
                          if (maxRuleNumber < filterList.TrafficMirrorFilters[i].IngressFilterRules[j].RuleNumber) {
                              maxRuleNumber = filterList.TrafficMirrorFilters[i].IngressFilterRules[j].RuleNumber;
                          }
                          if (filterList.TrafficMirrorFilters[i].IngressFilterRules[j].DestinationPortRange != undefined) {
                              let currentFromPort = filterList.TrafficMirrorFilters[i].IngressFilterRules[j].DestinationPortRange.FromPort;
                              let currentToPort = filterList.TrafficMirrorFilters[i].IngressFilterRules[j].DestinationPortRange.ToPort;
                              if (existIn2dArray(uniqueAllPortsRange, [currentFromPort, currentToPort])) {
                                  uniqueAllPortsRange = uniqueAllPortsRange.filter(item => (item[0] != currentFromPort && item[1] != currentToPort))
                              }
                              else {
                                  existingUnsedPorts.push([currentFromPort, currentToPort])
                                  unusedFilterId.push(filterList.TrafficMirrorFilters[i].IngressFilterRules[j].TrafficMirrorFilterRuleId)
                              }
                          }

                      }
                      for (j = 0; j < filterList.TrafficMirrorFilters[i].EgressFilterRules.length; j++) {
                          if (maxRuleNumber < filterList.TrafficMirrorFilters[i].EgressFilterRules[j].RuleNumber) {
                              maxRuleNumber = filterList.TrafficMirrorFilters[i].EgressFilterRules[j].RuleNumber;
                          }
                          if (filterList.TrafficMirrorFilters[i].EgressFilterRules[j].SourcePortRange != undefined) {
                              let currentFromPort = filterList.TrafficMirrorFilters[i].EgressFilterRules[j].SourcePortRange.FromPort;
                              let currentToPort = filterList.TrafficMirrorFilters[i].EgressFilterRules[j].SourcePortRange.ToPort;
                              if (existIn2dArray(existingUnsedPorts, [currentFromPort, currentToPort])) {
                                  unusedFilterId.push(filterList.TrafficMirrorFilters[i].EgressFilterRules[j].TrafficMirrorFilterRuleId)
                              }
                          }

                      }
                  }
              }
              console.log("ports to remove from rule ", JSON.stringify(existingUnsedPorts))
              console.log("ports to add to rule ", JSON.stringify(uniqueAllPortsRange))

              for (i = 0; i < unusedFilterId.length; i++) {
                  params = {
                      TrafficMirrorFilterRuleId: unusedFilterId[i]
                  }
                  await ec2.deleteTrafficMirrorFilterRule(params).promise().catch((err) => {
                      console.error("error deleting rule", err);
                      isError = true;
                  });

              }

              params = {
                  DestinationCidrBlock: '0.0.0.0/0',
                  RuleAction: 'accept',
                  RuleNumber: maxRuleNumber,
                  SourceCidrBlock: '0.0.0.0/0',
                  TrafficDirection: 'ingress',
                  TrafficMirrorFilterId: trafficMirrorFilterID,
                  Description: 'ingress rule for port ',
                  DestinationPortRange: {
                      FromPort: 0,
                      ToPort: 65535
                  },
                  DryRun: false,
                  Protocol: 6,
              };
              await ec2.createTrafficMirrorFilterRule(params).promise().catch((err) => {
                  console.error("error creating rule", err);
                  isError = true;
              });
              params = {
                  DestinationCidrBlock: '0.0.0.0/0',
                  RuleAction: 'accept',
                  RuleNumber: maxRuleNumber,
                  SourceCidrBlock: '0.0.0.0/0',
                  TrafficDirection: 'egress',
                  TrafficMirrorFilterId: trafficMirrorFilterID,
                  Description: 'egress rule for port ',
                  SourcePortRange: {
                      FromPort: 0,
                      ToPort: 65535
                  },
                  DryRun: false,
                  Protocol: 6,
              };
              await ec2.createTrafficMirrorFilterRule(params).promise().catch((err) => {
                  console.error("error creating rule", err);
                  isError = true;
              });
          }


          async function updateMirroringSessions(eniList, failedEnis, successEnis, isDelete) {
              //get Existing Mirroring session
              var isError = false;
              var ec2 = new aws.EC2();
              var i = 0;
              var params = {
                  Filters: [
                      {
                          Name: 'session-number',
                          Values: [ mirrorSessionNumber ]
                      }
                  ]
              }
              var mirrorSession = await ec2.describeTrafficMirrorSessions(params).promise().catch((err) => {
                  console.error("error describing traffic mirror sessions", err);
                  isError = true;
              });

              console.log("describeTrafficMirrorSessions: ", JSON.stringify(mirrorSession))
              console.log("enilist: ", JSON.stringify(eniList))

              var mirroringSessionToDelete = []
              if (!isError && mirrorSession.TrafficMirrorSessions != undefined) {
                  for (i = 0; i < mirrorSession.TrafficMirrorSessions.length; i++) {
                      console.log("compare session data: ", JSON.stringify(mirrorSession.TrafficMirrorSessions[i]));
                      var foundSession = eniList.find(item => {return item[1] === mirrorSession.TrafficMirrorSessions[i].NetworkInterfaceId});
                      if (foundSession) {
                          console.log("comparing more", trafficMirrorTargetID, trafficMirrorFilterID);
                          // if mirroring session exist for eni but not with same target and filter
                          if ( mirrorSession.TrafficMirrorSessions[i].TrafficMirrorTargetId != trafficMirrorTargetID ||
                               mirrorSession.TrafficMirrorSessions[i].TrafficMirrorFilterId != trafficMirrorFilterID ) {
                            console.log("found session of diff mirror/filter");     
                            mirroringSessionToDelete.push(mirrorSession.TrafficMirrorSessions[i].TrafficMirrorSessionId);
                          } else {
                            console.log("found session of matching mirror/filter", isDelete);
                            if (isDelete) {
                              mirroringSessionToDelete.push(mirrorSession.TrafficMirrorSessions[i].TrafficMirrorSessionId);
                            } else {
                              eniList = eniList.filter(item => item[1] != mirrorSession.TrafficMirrorSessions[i].NetworkInterfaceId);
                             }
                          }
                      }
                      else {
                          var foundOtherSessionFromSameLB = eniList.find(item => {return calcVxLanId(item[0]) === mirrorSession.TrafficMirrorSessions[i].VirtualNetworkId});

                          if (foundOtherSessionFromSameLB) {
                            mirroringSessionToDelete.push(mirrorSession.TrafficMirrorSessions[i].TrafficMirrorSessionId);
                          }
                      }
                  }
              }
              
              console.log("Deleting Mirroring sessions: ", JSON.stringify(mirroringSessionToDelete));
              if (mirroringSessionToDelete.length > 0) {
                  for(i = 0; i < mirroringSessionToDelete.length; i++) {
                    var params = {
                      TrafficMirrorSessionId: mirroringSessionToDelete[i]
                    }
                    var deleteSessionResult = await ec2.deleteTrafficMirrorSession(params).promise().catch((err) => { console.error(err); });
                    console.log(deleteSessionResult);
                  }
              }

              if (isDelete) {
                return;
              }

              console.log("New mirroring session to create: ", JSON.stringify(eniList))
              for (i = 0; i < eniList.length; i++) {
                  await createMirroringSession(eniList[i], mirrorSessionNumber, trafficMirrorFilterID, successEnis, failedEnis)
              }
          }


          async function deleteTrafficMirrorSessionInternal(params) {
              var isError = false;
              var ec2 = new aws.EC2();
              var data = await ec2.describeTrafficMirrorSessions(params).promise().catch((err) => {
                  console.error(err);
                  isError = true;
              });
              if (!isError) {
                  console.log(data); // successful response
                  if (data.TrafficMirrorSessions != undefined) {
                      for (var i = 0; i < data.TrafficMirrorSessions.length; i++) {
                          params = {
                              TrafficMirrorSessionId: data.TrafficMirrorSessions[i].TrafficMirrorSessionId,
                              DryRun: false
                          };
                          console.log(params);
                          var ec2Tmp = new aws.EC2();
                          var promise = await ec2Tmp.deleteTrafficMirrorSession(params).promise().catch((err) => { console.error(err); });
                          console.log(promise);
                      }
                  }
              }
          }


          async function createTrafficMirrorSessionForTargetGroup(allPorts,
          eniList) {
              if (tgNamesArray == undefined || tgNamesArray.length == 0)
                  return;
              if (tgNamesArray[0].trim() == "")
                  return;

              var params = {
                  Names: tgNamesArray
              }
              await getEnisAndPortOfTargetGroup(params, allPorts, eniList)
          }



          async function createTrafficMirrorSessionForLBs(allPorts, eniList) {
              if (elbNamesArray.length == 0)
                  return;
              if (elbNamesArray[0].trim() == "")
                  return;

              var params = {
                LoadBalancerNames: elbNamesArray
              };
              console.log("params ", JSON.stringify(params))
              var isError = false;
              var elb = new aws.ELB();
              var elbv2 = new aws.ELBv2();
              var ec2 = new aws.EC2();
              var data = await elb.describeLoadBalancers(params).promise().catch((err) => {
                  console.error(err);
                  isError = true;
              });
              console.log("describe elb ", JSON.stringify(data));
              var i = 0,
                  j = 0,
                  k = 0;
              if (!isError && data.LoadBalancerDescriptions != undefined) {
                  for (i = 0; i < data.LoadBalancerDescriptions.length; i++) {
                    var loadBalancerName = data.LoadBalancerDescriptions[i].LoadBalancerName;
                      if (!elbNamesArray.includes(data.LoadBalancerDescriptions[i].LoadBalancerName)) {
                          continue;
                      }
                      for (j = 0; j < data.LoadBalancerDescriptions[i].ListenerDescriptions.length; j++) {
                          if (data.LoadBalancerDescriptions[i].ListenerDescriptions[j].Listener.InstanceProtocol == "HTTP" ||
                              data.LoadBalancerDescriptions[i].ListenerDescriptions[j].Listener.InstanceProtocol == "TCP") {
                              allPorts.push(data.LoadBalancerDescriptions[i].ListenerDescriptions[j].Listener.InstancePort);
                          }
                      }

                      params = {
                          Filters: [{
                              Name: "attachment.instance-id",
                              Values: [

                              ]
                          }]
                      };
                      var counter = sampleSize < 1 ? targetGroups.TargetGroups.length : sampleSize
                      for (j = 0; j < data.LoadBalancerDescriptions[i].Instances.length && counter > 0; j++) {
                          params.Filters[0].Values[j] = data.LoadBalancerDescriptions[i].Instances[j].InstanceId
                          counter --
                      }
                      console.log("elb eni params", JSON.stringify(params));
                      if (params.Filters[0].Values.length > 0) {
                          var enis = await ec2.describeNetworkInterfaces(params).promise().catch((err) => {
                              console.error(err);
                              isError = true;
                          });
                          console.log("elb enis ", JSON.stringify(enis));
                          if (!isError && enis.NetworkInterfaces != undefined) {
                              for (var k = 0; k < enis.NetworkInterfaces.length; k++) {
                                  // Use only primary interface
                                  if (enis.NetworkInterfaces[k].Attachment != undefined && enis.NetworkInterfaces[k].Attachment.DeviceIndex == 0) {
                                      eniList.push([loadBalancerName, enis.NetworkInterfaces[k].NetworkInterfaceId])
                                  }
                              }
                          }
                      }
                  }
              }
              console.log("elb eniList ", JSON.stringify(eniList));

              // V2 Load balancers

              params = {
                Names: elbNamesArray
              };
              isError = false;
              data = await elbv2.describeLoadBalancers(params).promise().catch((err) => {
                  console.error(err);
                  isError = true;
              });
              console.log("elbv2 describeLoadBalancers ", JSON.stringify(data));
              if (!isError && data.LoadBalancers != undefined) {
                  for (i = 0; i < data.LoadBalancers.length; i++) {
                      if (!elbNamesArray.includes(data.LoadBalancers[i].LoadBalancerName)) {
                          continue;
                      }
                      isError = false;
                      params = {
                          LoadBalancerArn: data.LoadBalancers[i].LoadBalancerArn
                      }
                      await getEnisAndPortOfTargetGroup(params, allPorts, eniList)
                  }
              }
          }

          async function createMirroringSession(eni, sessionNumber, filterId,
          successEnis, failedEnis) {
              var params = {
                  NetworkInterfaceId: eni[1],
                  SessionNumber: parseInt(sessionNumber),
                  /* required */
                  TrafficMirrorFilterId: filterId,
                  TrafficMirrorTargetId: trafficMirrorTargetID,
                  VirtualNetworkId: calcVxLanId(eni[0])
              };
              console.log("params " + JSON.stringify(params));
              var ec2 = new aws.EC2();
              var promise = await ec2.createTrafficMirrorSession(params).promise().catch((err) => {
                  console.error(err);
                  failedEnis.push({ eni: eni, message: err.message });
              });
              if (promise != undefined) {
                  // get vpc cidr
                  var vpcPromise = await ec2.describeVpcs().promise().catch((err1) => {
                    console.error(err1)
                  })
                  let cidrBlock = []
                  if (vpcPromise !== undefined && vpcPromise["Vpcs"]) {
                    vpcPromise["Vpcs"].forEach((x) => {
                      cidrBlock.push(x["CidrBlock"])
                    })
                    console.log("cidrBlock: " + cidrBlock)
                    eni.push(cidrBlock)
                  }
                  successEnis.push(eni);
              }
              console.log(promise);

          }

          async function initFromCF(event, context) {
              console.log("event received:\n" + JSON.stringify(event));
              if (event.RequestType != undefined) {
                  // coming from cloudformation
                  var isDelete = (event.RequestType == "Delete")

                  var successEnis = [];
                  var failedEnis = [];
                  await createTrafficMirrorSessionForLBsAndTargetGroup(successEnis, failedEnis, isDelete)

                  if (isDelete) {
                    await response.send(event, context, "SUCCESS");
                    return;
                  }

                  console.log(JSON.stringify(failedEnis))
                  var responseData = {};

                  successEnis.forEach((x) => {
                    x[1] = ""
                  });
                  let set  = new Set(successEnis.map(JSON.stringify));
                  successEnis = Array.from(set).map(JSON.parse);

                  failedEnis.forEach((x) => {
                    x[1] = ""
                  });
                  set  = new Set(failedEnis.map(JSON.stringify));
                  failedEnis = Array.from(set).map(JSON.parse);

                  responseData['successEnis'] = JSON.stringify(successEnis);
                  responseData['failedEnis'] = JSON.stringify(failedEnis);
                  responseData['accountId'] = aktoAccountId;
                  console.log("starting to invoke lambda")

                  var invokeSaveCollectionNamesLambdaParams = {
                    FunctionName: saveCollectionNamesLambdaArn,
                    InvocationType: 'RequestResponse',
                    LogType: 'Tail' ,
                    Payload: JSON.stringify(responseData)
                  }
                  console.log("starting to invoke lambda with params", invokeSaveCollectionNamesLambdaParams)
                  var lambda = new aws.Lambda();

                  lambda.invoke(invokeSaveCollectionNamesLambdaParams, function(err, data) {
                    if (err) console.log("finished invoke lambda err", err, err.stack); 
                    else     console.log("finished invoke lambda data", data);           
                  });

                  console.log("finished invoke lambda");
                  console.log(await wait20());
                  responseData = {}

                  // when targetLB is given
                  var aktoDetails = await getAktoLBDetails();
                  responseData['kafkaIp'] = aktoDetails.PrivateIpAddress;
                  responseData['SubnetId'] = aktoDetails.Subnets;
                  responseData['VpcId'] = aktoDetails.VpcId;

                  await response.send(event, context, "SUCCESS", responseData);
              }

          }

          function wait20(){
              return new Promise((resolve, reject) => {
                  setTimeout(() => resolve("hello"), 20000)
              });
          }
    


          async function handlePeriodicEvents(event) {
              var successEnis = [];
              var failedEnis = [];
              await createTrafficMirrorSessionForLBsAndTargetGroup(successEnis, failedEnis, false)
              console.log("Mirroring session created for ", JSON.stringify(successEnis))
              console.log("failed ENIs ", JSON.stringify(failedEnis))
          }


          async function createTrafficMirrorSessionForLBsAndTargetGroup(successEnis, failedEnis, isDelete) {
              var ports = [];
              var enis = []
              await createTrafficMirrorSessionForLBs(ports, enis);
              await createTrafficMirrorSessionForTargetGroup(ports, enis)

              if (!isDelete) {
                await updateTrafficMirroringRule(ports)
              }
              var uniqueEnis = enis.filter(filterDuplicates);
              await updateMirroringSessions(uniqueEnis, failedEnis, successEnis, isDelete)
          }


          exports.handler = async function(event, context) {
              trafficMirrorTargetID = await getAktoTrafficMirrorTargetId();
              if (event.RequestType != undefined) {
                  // coming from cf
                  await initFromCF(event, context)
              } else {
                  // coming from periodic rule
                  await handlePeriodicEvents(event)
              }
          };
      Description: Auto create mirroring configuration
      TracingConfig:
        Mode: Active
  PeriodicEventRule:
    Type: 'AWS::Events::Rule'
    Properties:
      Description: Generate an event periodically
      Name: !Join
        - ''
        - - !Ref 'AWS::StackName'
          - '-'
          - PeriodicRule
      ScheduleExpression: rate(5 minutes)
      State: ENABLED
      Targets:
        - Arn: !GetAtt
            - CreateMirrorSession
            - Arn
          Id: !Ref CreateMirrorSession
  PeriodicEventPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !GetAtt
        - CreateMirrorSession
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !GetAtt
        - PeriodicEventRule
        - Arn

  LambdaVPCAccessRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: LambdaBasicAccessVPCPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'ec2:DescribeNetworkInterfaces'
                  - 'ec2:DescribeInstances'
                  - 'ec2:CreateNetworkInterface'
                  - 'ec2:DeleteNetworkInterface'
                  - 'ec2:AttachNetworkInterface'
                Resource: '*'
  LambdaSecurityGroupVPC:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      VpcId: !GetAtt 
        - CustomSourceAktoSetupDetails
        - VpcId
      GroupDescription: "Security group is required to create a lambda inside a VPC"
      
      SecurityGroupEgress: 
        - IpProtocol: "tcp"
          FromPort: 9092
          ToPort: 9092
          CidrIp: "0.0.0.0/0"
      

  SaveCollectionNames:
    Type: 'AWS::Lambda::Function'
    Properties:
      Runtime: nodejs12.x
      Timeout: 60
      Role: !GetAtt
        - LambdaVPCAccessRole
        - Arn
      Handler: nodejs/index.handler
      VpcConfig:
        SecurityGroupIds: 
          - !GetAtt 
            - LambdaSecurityGroupVPC 
            - GroupId
        
        SubnetIds: !GetAtt 
          - CustomSourceAktoSetupDetails
          - SubnetId
      Environment:
        Variables:
          PRIVATE_IP: !GetAtt
            - CustomSourceAktoSetupDetails
            - kafkaIp
          SUCCESS_ENIS: !GetAtt
            - CustomSourceAktoSetupDetails
            - successEnis
      Code:
        S3Bucket: !Sub 'akto-setup-${AWS::Region}'
        S3Key: 'templates/mirroring-collections-split.zip'
      Description: Send collection name to id mapping to Akto modules
      TracingConfig:
        Mode: Active